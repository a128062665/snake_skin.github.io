# C语言要点

### while（m）

当m等于0时表示错误，不成立，会终止循环

### do...while...

```c
do
{
	......
}while(表达式);
```

do...while会先执行一次后再执行表达式，与for和while不同，主要用于人机交互

### 运行程序时如果无法输入英文，将输入法切换为英文模式

### switch（非重点）

```c
switch(表达式)
{
	case 常量表达式1： 语句1；break;
	case 常量表达式2： 语句2；break;
	default:		   语句3；break;
	case 常量表达式3： 语句4；break;
}

```

常量表达式只能是：

1.枚举常量2.数值常量3.字符常量4.常变量5.宏

注意：普通变量和枚举变量不能做常量表达式

#### switch的表达式可以是任何类型，但在vc++中只允许为int或char

执行完case语句后，流程控制就转移到下一个case语句继续执行， case常量表达式只是起语句标号的作用，并不是在该处进行条件判断，在执行switch语句时，根据表达式的值匹配case语句，然后从此case语句开始执行下去，不再进行判断

swutch是选择不是循环，如果在switch中出现了break语句，该语句的功能只是退出switch语句转去执行它下面的语句。在switch中出现continue是错误的，除非switch本身就属于for或while循环的一部分

### break

如果用于循环，是用来终止==整个==循环

如果用于switch，是用来终止**整个**switch

**不能直接用于if**，除非if处于某个循环内部的句子（此时的break起到终止整个循环的作用，不是终止if）

在**多层循环和switch多个嵌套**中，break只能终止距离它最近的循环

```c
for(i=0;i<3;++i)
	{
		if(3>2)
			break;//break虽然是if内的语句，但是作用于for
		printf("你好！\n");//这个语句永远不会输出，因为前面的break终止了整个循环
	}
```

### continue

用于跳过本次循环余下的语句，转去判断是否需要执行下次循环

```c
for(1;2;3)
{
	A;
	B;
	continue;//如果执行该语句，则执行完该语句后，C和D都会被跳过，然后继续执行语句3
	C;
	D;
}
```

```c
do
	{
		if(i%2)
		{
			i++;
			continue;//这里的continue执行后会跳到while进行判断是否循环
		}
		i++;
		s+=i
	}while(i<5)
	printf("%d\n",s);
```

# 函数

### 函数例子

```c
#include<stdio.h>
void max(int i,int j)//max是函数名,i和j是形式参数,简称形参,void表示函数没有返回值   函数名可自定义
{
	if(i>j)
		printf("%d\n",i);
	else
		printf("%d\n",j);
}

int main(void)
{
	int a,b,c,d,e,f;
	a = 1,b = 2,c = 3,d = 9,e = -5,f = 100;
	max(a,b);//先执行max(a,b);之后,系统会判断后再返回查看前面的函数max,使用函数时会把a,b的值分别发送给i,j,系统会给ij分配空间,使用完函数之后会释放空间
	max(c,d);
	max(e,f);
	return 0;
}
```

### 为什么需要函数

避免了重复性操作

有利于程序的模块化（无法解决大块分小块，无法解决再继续分）

### 什么是函数

逻辑上：能够完成特定功能的独立代码块

物理上：能够接收数据（也能不接受数据）

​				能够对接受的数据进行处理

​				能够将数据处理的结果返回（也能不返回）

总结：函数是个工具，它是为了解决大量类似问题而设计的

```c
#include<stdio.h>
int f(void)//括号中的void表示该函数不能接受数据 int表示函数返回值的类型是int
{
	return 10;//返回的值是10
}
void g(void) //详情见return表达式的含义
//当返回值是除了void其他时,return可以有值
//当函数返回值类型是void时,return不能有值,也不会返回值
//意义是终止函数,不向被调函数返回任何职
{
//	return 10;//error
}
int main(void)
{
	int j=88;
	j=f();//括号内不能输入数据,因为已经有返回值10了,否则会出错
	printf("%d\n",j);
//	j=g();
	return 0;
}
```

### 如何定义函数

#### 函数格式  

```c
函数的返回值 函数名(函数的形参列表)
{
	函数的执行体
}
```

```c
eg.
void max(int i,int j)
{
	if(i>j)
		printf("%d\n",i);
	else
		printf("%d\n",j);
}
```



#### 函数返回值的类型

函数返回值的类型也称为函数的类型,因为如果函数名前的返回值类型和函数执行体中的return表达式中表达式的类型不同的话,则最==终函数返回值的类型要以函数名前的返回值类型为准==

```c
#include<stdio.h>
int f()//函数的返回值类型是int 所以最终函数的返回值是10
{
	return 10.5;
}
int main(void)
{
	int i=99;
	double x=6.6;
	x=f();//函数的返回值类型是int 所以最终函数的返回值是10
	printf("%lf\n",x);//输出结果为10.000000
	return 0;
}
```

#### return表达式的含义

1.终止被调函数,向主调函数返回表达式的值

2.如果表达式为空,则只终止函数,不向主函数返回任何值

3.break是用来终止循环和switch的,return是用来终止函数的

```c
int f()
{
	return 10;//终止函数,向主调函数返回表达式的值
}

void f()
{
	return;//终止函数,不向主调函数返回任何值
}
```

void的return可以是空,但是其他类型的return不能为空,必须有返回值

#### 函数的分类

1.有参函数(形参) 和 无参函数(void)

2.有返回值函数 和 无返回值函数 【return的返回】

3.库函数(printf等系统有的) 和 用户自定函数(自定义的函数名)

4.普通函数 和 主函数(main函数)

​			==**一个程序必须有且只能有一个主函数**==

​			==**主函数可以调用普通函数,普通函数不能调用主函数(递归除外)**==

​			==**普通函数可以相互调用**==

​			==**主函数是程序的入口,也是程序的出口**==

5.值传递函数 和 地址传递函数【在指针】

#### 判断素数

```c
#include<stdio.h>
bool IsPrime(int val)//bool表示判断类型，用ture和false
{
	int i;
	for(i=2;i<val;i++)//1不是素数，所以从2开始
	{
		if(val%i==0)//从2到val依次进行取余
			break;//如果取余后结果是0，就是素数，终止循环
	}
	if(i==val)
		return true;
	else 
		return false;
}
int main(void)
{
	int m;
	scanf("%d",&m);
	if(IsPrime(m))
		printf("YES!\n");//这是ture的结果
	else
		printf("NO!\n");//这是false的结果
	return 0;
}
```

#### 函数的声明

==函数调用和函数定义的顺序==

​		==如果函数调用写在了函数定义的前面,则必须加函数前置声明==

​		==函数前置声明:==

​						==1.告诉编译器即将可能出现的若干个字母代表的是一个函数==

​						==2.告诉编译器即将可能出现的若干个字母所代表的函数的形参和返回值的具体情况==

​						==3.函数声明是一个语句,末尾必须加分号==

​						==4.对库函数的声明是通过#include<库函数所在的文件的名字.h>来实现的==

声明可以不写形参

如果想把普通函数放在主函数后面,就需要在主函数前进行函数声明,函数声明格式:void f();  

如果直接将普通函数放在主函数后面,会出错



```c
#include<stdio.h>
void f(int);//这里是函数声明,分号不能丢,声明可以不写形参
int main(void)//这是主函数
{
	f();
	return 0;
}
void f(void)//这是普通函数
{
	printf("哈哈!\n");
}
```

普通函数调用普通函数,被调用的普通函数要放在普通函数的前面(因为c的执行顺序是从前向后的,前面未检测到被调用的函数,就无法使用);也可以在前面进行函数声明

```c
//这是一个出错的程序
#include<stdio.h>
//void f(void);   在这里提前进行函数声明可以解决问题
void g(void)
{
	f();//因为函数f的定义放在了后面,所以语法出错
 
}
void f(void)
{
	printf("哈哈!\n");
}
int main(void)
{
	f();
	return 0;
}

```

#### 形参与实参

个数相同	位置一一对应	数据类型必须相互兼容

#### 如何设计函数

如何在软件开发中合理的设计函数来解决实际问题

​		一个函数的功能尽量独立，单一

​		多学习，多模仿别人

```c
//从2到该数字有哪些是素数
//只用main函数实现，有局限性：1.代码的重用性不高 2.代码不容易理解
#include<stdio.h>
int main(void)
{
	int val;
	int i;
	int j;
	scanf("%d",&val);
	for(i=2;i<=val;++i)
	{
		for(j=2;j<i;++j)
		{
			if(0==i%j)
				break;
		}
		if(j==i)//因为素数只能对本身取余为0,所以最后两个值是相同的才能取余
		printf("%d\n",i);
	}
	return 0;
}
```

```c
//本程序与上面的程序比较,代码量更少,可重用性更高
#include<stdio.h>
//本函数的功能是:判断m是否是素数,是返回ture,不是返回false
bool IsPrime(int m)
{
	int i;
	for(i=2;i<m;++i)
	{
		if(0==m%i)
			break;
	}
	if(i==m)
		return true;
	else
		return false;
}
int main(void)
{
	int val;
	int i;
	scanf("%d",&val);
	for(i=2;i<=val;++i)
	{
		if(IsPrime(i))
			printf("%d\n",i);
	}
	return 0;
}

```

```c
//本函数的功能是把1到n之间所有的素数显示在显示器上输出
//如果放在上面程序的IsPrime函数之后会更好，方便需要时进行调用
//因为这里调用了IsPrime函数，所以需要放在IsPrime函数的后面的任意位置/函数声明（主函数的前面）
void TraverseVal(int n)
{
	int i;
	for(i=2;i<=n;++i)
	{
		if(IsPrime(i))//调用了IsPrime函数
			printf("%d\n",i);
	}
}
//
//后面主函数的内容
int main(void)
{
	int val;
	scanf("%d",&val);
	TraverseVal(val);
	return 0;
}
```

#### 变量的作用域和存储方式

按作用域分:

##### 		全局变量

​					在所有函数外部定义的变量叫全局变量

​					==全局变量使用范围:从定义位置开始到整个程序结束==

##### 		局部变量

​					在一个函数内部定义的变量或者函数的形参都统称为局部变量

​					局部变量使用范围:只能在本函数内部使用

```c
//这里的k属于全局变量   i和j都属于局部变量
void f(int i)
{
	int j=20;
    printf("%d\n",k);//这里的k是无效的,不受全局变量影响
}
k=100;
void f(int i)
{
	int j=20;
    printf("%d\n",k);//这里的k是有效的,受全局变量影响
}
```

##### 变量命名冲突问题

在一个函数内部如果定义的局部变量的名和全局变量名一样时,局部变量会屏蔽掉全局变量

```c
#include<stdio.h>
int i=99;
void f(int i)//局部变量名与全局变量
{
	printf("i=%d\n",i);
}
int main(void)
{
	f(8);//最终输出的值为i=8;因为局部变量屏蔽了全局变量
	return 0;
}
```

按变量的储存方式分:(后面讲,可不了解)

静态变量

自动变量

寄存器变量



#### 函数的小知识点

函数可位于printf语句中的输出参数

求的结果是几个数就几个形参

```c
//判断两个数之间的最大值 
#include<stdio.h>
int max(int i,int j)//求的结果是几个数就几个形参
{
	if(i>j)
		return i;
	else
		return j;
}
int main(void)
{
	int a,b,c,d,e,f;
	a=1,b=2,c=3,d=7,e=-4,f=100;
    //函数可位于printf语句中的输出参数
	printf("%d\n",max(a,b));  
	printf("%d\n",max(d,c));
	printf("%d\n",max(e,f));
	
}
```

返回值是使用return

void max(void)前面的void表示没有返回值(return)，但可以有语句，后面的void表示不需要形参/不需要发动数据 ；

如果前面有void，函数执行体内可以没有语句，如果前面没有void，函数执行体内必须有语句；

后面如果有void，在主函数中的max（）括号内不能有值

普通函数和主函数内定义的变量不通用，即使彼此有相同名字的变量，也不冲突

函数执行的顺序是先从main主函数开始，在其中遇到普通函数的格式后再执行普通函数

参数不能重复定义

```c
void f(int i)//这里已经对i进行了一次定义
{
	int i=99;//这里的定义是错误的,不能重复定义
			 //正确的是:i=99;
	printf("i=%d\n",i);
}
```

# 指针

### 认识指针的程序

```c
#include<stdio.h>
int main(void)
{
	int*p;/*
		  这是一个指针变量
		  p是变量的名字  int*表示p变量存放的的int类型变量的地址   
		  int*p不表示名字是*p的int变量
		  理解:p是变量名,p变量的数据类型是int*
		  int*是用来存放变量地址的一种数据类型

		  */
	int i=3;
	int j;
	p=&i;/*
		 1.表示p保存i的地址,因此p指向i;
		 2.修改p的值不影响i的值,修改i的值不影响p的值
		 3.如果一个指针变量指向了某个普通变量,则 *指针变量 就完全等同于 普通变量
		例子:如果p是个指针变量,并且p存放了普通变量i的地址
			 则p指向了普通变量i
			 *p就可以表示完全等同于i
			 在所有出现*p的地方都可以替换成i,在所有出现i的地方都可以替换成*p
		   
		 */
	j=*p;//等价于j=i;
    	 //用p的话是将地址保存给p,需用取址符,表示为p=&i;
 		 //用*p的话是使用之前保存的地址,表示为j=*p;
	printf("i=%d,j=%d\n",i,j);

	return 0;
}
```

指针就是地址,地址就是指针

地址就是内存单元的编号(只是编号,代表变量存放的位置)

指针变量是存放地址的变量

指针和指针变量是两个不同的概念

注意:通常我们叙述时会把指针变量简称为指针,但是他们的含义并不一样

### 指针的作用

#### 指针的重要性

表示一些复杂的数据结构

==快速的传递数据（减少了内存的耗用）==

==使函数返回一个以上的值==

能直接访问硬件

能够方便的处理字符串

是理解面向对象语言中引用的基础

总结:指针是C语言的灵魂

#### 指针的定义

地址:内存单元的编号

​		 从零开始的非负整数(8位的二进制)

​		  范围:4G【内存条的大小】(0--(4G-1))

指针:指针就是地址,地址就是指针

​		 指针变量是存放地址的变量,或者说指针变量是存放内存单元编号的变量

​		 指针和指针变量是两个不同的概念

​		 注意:通常我们叙述时会把指针变量简称为指针,但是他们的含义并不一样

​		 指针的本质是一个操作受限的非负整数(能相减,但相加和乘除不行)(因为存放的是编号,不是值)

​		在定义多个指针时格式为int * p,*q;

#### 指针的分类

##### 基本类型指针

看认识指针的程序

###### 常见错误

```c
//使用指针变量输出i的值
#include<stdio.h>
int main(void)
{
	int*p;
	int i=5;
	*p=i;//*p表示以p的内容为地址的变量(p本身是一个垃圾值)
    	 //系统只分配给了p和i这两个空间,使用*p相当于冒出了第三个没有的空间
    	 //相把i赋给p的话应该用p=&i;
	printf("%d\n",*p);

	return 0;
}
```

```c
//使用指针变量输出i的值
#include<stdio.h>
int main(void)
{
	int*p;
	int i=5;
	p=&i;
	printf("%d\n",p);/*这个语句无法输出i的值
					输出的结果是p存放i地址单元的编号,
					如果p没有指向i的话,输出的就是一个垃圾值
					*/
    printf("%d\n",*p);/*这个语句能输出i的值
    				表示的是上面i存放在p的地址,
    				输出地址即输出i的值
  
	return 0;
}
```

```c
//重要!!!有较多的错误!!!必须理解!!!
#include<stdio.h>
int main(void)
{
	int* p;
	int* q;
	int i=5;
	p=&i;
	//*q=p;//error 两者的类型不同,*q的类型是int,q的类型是int*,语法会出错
	//*q=*p; //error 因为有p指向了i,所以程序有对*p的控制权限(给*p分配了空间);
			 //但是q没有指向任何,所以*q代表的内存单元的控制权限就没有分配给本程序(没有给*q分配空间,相当于不存在*q),因此无法赋值
	p=q;//q没有指向,所以q是垃圾值,q赋给p,p也变成了垃圾值

	printf("%d\n",*q);/*与上面的*q=*p类似.
					  q未进行指向,所以q指向了一个未被授权的野地址,本身是一个垃圾值
					  
					  q的空间是属于本程序的,所以程序可以读写q的内容
					  但是如果q的内部是垃圾值(没有指向),则本程序不能读写*q的内容,此时输出的q是垃圾值,输出的*q没有值/出错
					  因为此时*q所代表的内存单元的控制权限没有分配给本程序
					  所以在输出时会出错,因为不存在*q(如果进行了指向,就存在*q)
				 	  */

	return 0;
}
```

```c
//对上方程序的改进,是正确的程序
#include<stdio.h>
int main(void)
{
	int*p;
	int*q;
    int a=3;
	int i=5;
    q=&a;//进行了指向,存在了*q
	p=&i;//进行了指向,存在了*p
	*q=*p;
	printf("%d\n",*q);
	return 0;
}
//输出结果为:3
```

###### 指针互换两个数字

```c
#include<stdio.h>
//函数声明
void huhuan_1(int,int);
void huhuan_2(int*,int*);
void huhuan_3(int*,int*);
//主函数,这里调用的是huhuan_3普通函数
int main(void)
{
	int a=3;
	int b=5;

	huhuan_3(&a,&b);//将地址赋给int*p和int*q需要用取址符&(相当于进行了指向)
	printf("a = %d,b = %d\n",a,b);
	
	return 0;
	
}
void huhuan_3(int* p,int* q)
{
	int t;/*如果要互换*p和*q的值,则t需要定义成int,不能定义成int*,否则语法出错;
			因为使用int*t的话没有进行指向,所以指向了野指针,系统没有其权限(没有给*t分配空间);
			如果要用int*t的话,就需要定义一个x值,然后使得t指向x,并且后面互换时的t都换成*t就可以了;
			eg: int*t;
				int x;
				x = 1;
				t = &x;
				*t=*p;
				*p=*q;
				*q=*t;
		  */
	t=*p;
	*p=*q;//*p代表的是a,*q代表的是b
	*q=t;
	return;//return可以省略,不省略是为了让人明白结束了
}
//以下两个都不能完成互换功能
void huhuan_1(int p,int q)//可以参考普通互换两个数字
    					  //实参(ab)发送值给形参(pq),但改变后的形参(pq)不会发送给实参(ab)
{
	int t;
	t=p;
	p=q;
	q=t;//最后互换的是形参pq的值,对ab的值没有改变
	return;
}
void huhuan_2(int* p,int* q)
{
	int *t;
	t=p;
	p=q;
	q=t;
    /* *p和*q才能代表实参ab的值,pq改变的是pq的值,并不改变ab
    	如果换成*p和*q,需要把int*t改成int t,或者对t指向
    */
	return;
}
```

```c
/*
如何通过被掉函数修改主调函数普通变量的值
1.实参必须为该普通变量的地址
2.形参必须为指针变量
3.在被掉函数中通过  *形参名=...  的格式就可以修改主调函数相关变量的值
*/
#include<stdio.h>
void g(int * p,int * q)//2.
{
	*p=1;//3.
	*q=2;//3.
}
int main(void)
{
	int a = 3,b = 5;
	g(&a,&b);//1.
	printf("%d %d\n",a,b);
	return 0;
}
//输出结果为: 1 2
```

###### 普通互换两个数字

```c
#include<stdio.h>
void huhuan_1(int p,int q)
{
	int t;
	t=p;
	p=q;
	q=t;
	printf("p=%d,q=%d\n",p,q);
	return;
}
int main(void)
{
	int a=3;
	int b=5;
	huhuan_1(a,b);	//这里输出a=5,b=3
    printf("a=%d,b=%d\n",a,b);//这里输出a=3,b=5
    //可以发现,实际上并没有互换ab的值,只是输出改变了
    //上面的函数也没有完成对实参ab的互换,只是互换了pq形参
    //只能通过指针修改ab的值
	return 0;
}
```

##### 指针和数组

###### 	指针和一维数组

​			一维数组名
​					==一维数组名是个指针常量==
​					==它存放的是一维数组第一个元素的地址==

```c
#include<stdio.h>
int main(void)
{
	int a[5];//a是数组名,5是数组元素的个数 元素就是变量 a[0]--a[4]
	//int a[3][4];//表示3行4列的二维数组 a[0][0]是第一个元素 a[i][j]第i+1行j+1列
	int b[5];
	//a = b;//error a是常量,无法改变
	printf("%#X\n",&a[0]);//十六进制输出一维数组的第一个元素的地址  因为取地址,所以这里使用了取址符&,否则输出的是第一个元素的值,没有进行初始化的话是一个垃圾值
	printf("%#X\n",a);//十六进制输出数组名a的地址
	return 0;
}
/*
输出结果是:
0X19FF1C
0X19FF1C
	总结:
		一维数组名
			一维数组名是个指针常量(常量不可更改)
			它存放的是一维数组第一个元素的地址
			
结论:这说明数组变量名是一个指针常量,可以理解为a是int*类型,它存放数组第一个元素的地址,可以说数组名和第一个元素是等价的,通过使用数组名访问到第一个元素
*/
```

###### 下标和指针的关系

```c
#include<stdio.h>
int main(void)
{
	int c[5]={1,2,3,4,5};
    printf("%d\n",c);//输出c的地址编号1703708
	printf("%d\n"(c+1));//使c的地址编号增加一个单元,因为int是四个字节,所以加4,输出为1703712
	printf("%d\n",*c);//输出结果是1,输出了c[0]
	printf("%d\n",*(c+3));//表示输出[0+3]输出结果是4,输出了c[3]
	return 0;
}
```

###### 数组的地址

```c
#include<stdio.h>
int main(void)
{
	int c[5]={1,2,3,4,5};
	printf("%d\n",&c[0]);//输出为:1703708
	printf("%d\n",&c[1]);//输出为:1703712
	return 0;
//结论:c+1完成了地址向后移一个单元,int是4个字节,所以每后一一个单元会增加4
}
```

###### 确定一个一维数组

```c
//输出一维数组的内容
#include<stdio.h>
void f(int * pArr,int len)//输出一个一维数组需要两个参数,第一个是数组名,第二个是元素个数;由于数组名是指针常量,所以前面需要加*
{
	int i;
	for(i=0;i<len;i++)//通过循环不断获得数组中下一个元素的地址后输出
		printf("%d  ",*(pArr+i));//这里的*(pArr+i)等价于pArr[i]
	printf("\n");
}
int main(void)
{
	int a[5]={1,2,3,4,5};
	int b[6]={-1,-2,-3,-4,-5,-6};
	int c[100]={11,22,33,44,55};
	f(a,5);//a是int*
	f(b,6);
	f(c,100);
	return 0;
}
```

###### 修改一个数的值

```c
//使用指针
#include<stdio.h>
void f(int * p)
{
	*p = 10;//i=10;
}
int main(void)
{
	int i=6;
	f(&i);
	printf("%d\n",i);
	return 0;
}
```



```c
//不使用指针
#include<stdio.h>
int f(int p)
{
	return 10;
}
int main(void)
{
	int i=6;
	i=f(i);
	printf("%d\n",i);
	return 0;
}
```



###### 修改一维数组值

```c
#include<stdio.h>
void f(int * pArr,int len)
{
	pArr[3]=88;//也可以是*(pArr+3)=88;
}
int main(void)
{
	int a[5]={1,2,3,4,5};
	printf("%d\n",a[3]);//输出为4
	f(a,6);
	printf("%d\n",*(a+3));//输出为88
    					  //因为修改了a的地址,a的值也改变了
    					  //这里的*(a+3)等价于a[3]
	return 0;
}
```

###### 指针变量的运算

如果两个指针变量指向的是同一块连续空间中不同的存储单元.则这两个指针变量才可以相减

指针变量不能相加、相乘、相除

```c
#include<stdio.h>
int main(void)
{
	int * p;
	int * q;
	int a[5];
	p = &a[1];
	q = &a[4];
	printf("p和q所指向的单元间隔%d个单元\n",q-p);
    //输出值为 3 
    //如果是p-q则没有意义，输出是 -3
    //如果不是q-p而是单独的q，p的话，输出的是地址，他们之间的地址相隔14，因为int是4个字节
}
```

###### 指针变量占的字节

工具:sizeof(数据类型/变量名)

功能:返回值就是该数据类型所占的字节数

==结论:char int double等所占的字节都是4个==

```c
#include<stdio.h>
int main(void)
{
	char ch = 'A';
	int i = 99;
	double x = 66.6;
	char * p = &ch;
	int * q = &i;
	double * r = &x;
	printf("%d %d %d\n",sizeof(p),sizeof(q),sizeof(r));
}
//输出结果为 4 4 4 
```

##### 指针和函数

##### 指针和结构体

##### 多级指针

==总结:要存放一个地址,就需要在存放地址的类型后加*==

```c
#include<stdio.h>
int main(void)
{
	int i = 10;
	int * p = &i;//因为i的地址是int,想存放它要使用int*
	int ** q = &p;//因为p的地址是int*,想存放它要使用int**
	int *** r = &q;//因为q的地址是int**,想存放它要使用int***
				  //总结:要存放一个地址,就需要在存放地址的类型后加*

	//r = &p //error 因为r是int *** 类型,r只能存放int ** 类型变量的地址

	printf("i = %d\n",***r);//输出结果: i = 10
	return 0;

}
```

```c
//函数调用下的多级指针(比较绕)
#include<stdio.h>
void f(int * *q)//保持与&p的类型一致
{				//事实上就是int*存放了*q的地址,所以应该写成int**q
	//**q = 1; //这里的**q是*p   *q是p
	printf("%d\n",**q);//输出的实际是i的值
}
void g()
{
	int i = 10;
	int * p = &i;
	f(&p);//p是int*类型 &p是int**
    //在这里p的类型已经是*p了,使用了&又进行了一次指向,因此调用的f函数形参的类型是**q
}

int main(void)
{
	g();
	return 0;
}
```



### *的含义

1.乘法

2.定义指针变量  (int*p  )

​	定义了一个名字叫p的变量,int*表示p只能存放int变量的地址

3.指针运算符

​	该运算符放在已经定义好的指针变量的前面

​	如果p是一个已经定义好的指针变量

​	则*p表示以p的内容为地址的变量

### 动态内存分配

#### 传统数组的缺点

传统数组也叫静态数组

1.==数组长度必须事先制定,且只能是常整数,不能是变量==

​			eg: 	int a[5];//right

​					   int len = 5;//error

2.==传统形式定义的数组,该数组的内存程序员无法手动释放==

​	在一个函数运行期间,系统为该函数 中数组所分配的空间会一直存	在,直到该函数运行完毕时,数组的空间才会被系统释放

3.==数组的长度一旦定义,其长度就不能再更改==

​	数组的长度不能在函数运行的过程中动态的扩充或缩小

4.==传统方式定义的数组不能跨函数使用==

​	a函数定义的数组,在a函数运行期间可以被其他函数使用,但a函数运	行完毕之后,a函数中的数组将无法在被其他函数使用

#### 为什么需要动态内存分配

==动态数组很好的解决了传统数组的缺陷==

#### 动态内存分配举例_动态数组的构造

##### 认识malloc函数

malloc是memory(内存)和allocate(分配)的缩写

```
int * p = (int *)malloc(8);
这里前面的int*p是定义了一个p的类型是int*，如果已经定义的话就使用p=(int*)malloc(8);

括号的(int*)实际上是强制类型转换,并不属于malloc函数的一部分,作用是使p指向的地址是int*类型,此时p指向4个字节并返回第1个字节地址(不使用强制类型转换的话,p默认是指向第1个字节地址并返回第1个字节的地址);p指向了2个4个字节,两个整体;
在构造一维数组时,前4个字节就是第一个值,后4个字节就是第二个值,依此类推.

括号的(8)是请求系统分配8个字节
```

```c
#include<stdio.h>
#include<malloc.h>//需要malloc的头文件
int main(void)
{
	int i = 5;//静态分配 4个字节 
	int * p = (int *)malloc(4);//这里其实是进行了指向
    						   //p存放的是第1个字节的地址,但是由于p本身是int*类型,所以p指向了前4个字节;如果使用*(p+1),p就会指向接下来后四个字节
	/*
		1.要使用malloc函数,必须添加malloc.h头文件
		2.malloc函数只有一个形参,并且形参是整形
		3.形参4表示请求系统分配4个字节
		4.malloc函数只能返回第一个字节的地址(可以使用强制类型转换表示指向的变量占多少字节)
		5.一共分配了8个字节,p变量占4个字节,p指向的内存占4个字节
		6.p本身的内存是静态分配的,p指向的内存是动态分配的

	*/

	*p = 5;//*p代表的就是一个int变量,只不过*p这个整形变量的内存分配方式和int i=5的i变量的分配方式不同
    	   //因为前面对p进行了指向,所以这里不会出错
	free(p);//表示手动把p所指向的动态内存释放掉,p本身的静态内存不释放,在函数结束时系统会自动释放
    		//动态内存释放掉之后,*p=5就会被释放掉,释放掉相当于没有了指向,后面也无法输出5,输出的值是垃圾值
	printf("%d\n",*p);
	return 0;

}
```

```c
#include<stdio.h>
#include<malloc.h>
void f(int * q)
{
	*q = 200;
	//free(q);不能进行释放,否则*q存放的地址会被释放,最后无法输出200,而是垃圾值
}
int main(void)
{
	int * p = (int *)malloc(sizeof(int));//相当于进行了指向,系统给*p分配了空间
    //在分配字节时,最好使用sizeof(int),因为不同机器不同软件int所占字节是不同的
    									 //sizeof(int)返回值是int所占的字节数
    									 //p存放的是第1个字节的地址,但是由于p本身是int*类型,所以p指向了前4个字节;如果使用*(p+1),p就会指向接下来后四个字节
	*p = 10;
	printf("%d\n",*p);
	f(p);
	printf("%d\n",*p);
	return 0;
}
```

##### 一维数组构造

```c
//动态构造一维数组,可以自定数组元素个数并且给各元素赋值
#include<stdio.h>
#include<malloc.h>
int main(void)
{
	int * p;
	int len;
	int i;
	printf("请输入函数存入的个数:");
	scanf("%d",&len);
	p =(int *)malloc(4*len);/*对p进行了指向 本行动态构造了一维数组,数组的元素个数是len,每个元素都是int类型  本行代码类似于int p[len];的功能,但如果使用int p[len];的话不符合语法,是错误的*/
	for(i=0;i<len;i++)
		scanf("%d",&p[i]);//对动态一维数组赋值
	for(i=0;i<len;i++)
		printf("%d\t",p[i]);//对动态一维数组输出
    free(p);//释放动态分配的数组,相当于不存在
	return 0;
}
```

![image-20210131222739195](C:\Users\sp\AppData\Roaming\Typora\typora-user-images\image-20210131222739195.png)

pArr存放的是第1个字节的地址,但是由于指向的是:int**类型,所以pArr指向了前4个字节;如果使用*:*(pArr+1),pArr就会指向接下来后四个字节,依此类推

##### 认识realloc函数

动态 增加/缩小 内存

需要头文件.能够改变动态数组指向的字节大小

eg. int * p = (int *)malloc(20);这里指向的字节大小是20个字节;

通过recalloc(p,50)和recalloc(p,12)可以改变字节的大小为50/12(不是增加/减少,而是直接改变);这里的p是函数名,后面的参数是改变的字节;

如果改变后的值大于原先的值,原来的数据会保留,对动态一维数组来说能增加新的元素个数和赋值

如果改变后的值小于原先的值,超过改变字节 的数据会丢失

#### 静态内存和动态内存的比较

静态内存是由**系统自动分配**,**自动释放**

静态内存是在**栈**分配的(使用时按顺序压栈,用完按顺序出栈)

动态内存是由**程序员手动分配**,**手动释放**(如果忘记释放,内存会越用越少直到死机)

动态内存是在**堆**分配的

#### 跨函数使用内存的问题

静态内存不能跨函数使用,因为在函数结束时静态内存会释放掉

动态内存可以跨函数使用,因为在构造动态和内存后,没有手动释放的话它会一直存在,可以在不同函数之间使用;可以使用f函数调用g函数内的动态内存的值输出

# 结构体

#### 为什么需要结构体

​	为了表示一些复杂的事物，而普通的基本类型难以满足实际要求

#### 什么叫结构体

​	把一些基本类型数据组合在一起形成的一个新的复合数据类型

#### 如何定义结构体

​	3种方式

​		最好是使用第一种方式

```c
#include<stdio.h>
//第一种  还需要在主函数中定义变量名
struct Student  //Student是自定义的给struct起的名字
{
	int age;
	float score;
	char sex;
};
//第二种  在定义的同时定义了变量名(不好,意味着只能定义一次)
struct Student
{
	int age;
	float score;
	char sex;
} st2;
//第三种  没有给struct起名 在定义的同时定义了变量名
struct   
{
	int age;
	float score;
	char sex;
} st3;

int main(void)
{
	struct Student st = {80,60.6,'F'};//这里是 第一种 定义了变量名st
	return 0;
}
```

#### 怎样使用结构体变量

##### 赋值和初始化

​		定义的同时可以整体赋初值

​		如果定义完之后，则只能单个的赋初值

```c
#include<stdio.h> 
//相当于定义了一个数据类型是struct 自定义了它的名字是Student
struct Student  
{
	int age;
	float score;
	char sex;
};
int main(void)
{
	struct Student st = {80,60.6,'F'};//初始化 定义st的同时赋初值
	struct Student st2;//定义了st2没有同时进行赋值
	st2.age = 10;//定义完之后只能单个赋值
	st2.score = 8.8;
	st2.sex = 'f';
	printf("%d %f %c\n",st.age,st.score,st.sex);
	printf("%d %f %c\n",st2.age,st2.score,st2.sex);
	return 0;
}
```



##### 如何取出结构体变量中的每一个成员

​		第二种更常用

​		1.结构体变量名 + .  + 成员名  eg.   st2.age = 10;

​		==2.指针变量名->成员名   		 eg.   st->age = 10;== 这种方式需要提前有指针变量

​		指针变量名->成员名 在计算机内部会被转化成(*指针变量名).成员名 的方式执行  所以说这两种方式是等价额

关于第二种用法:

1.st->age在计算机内部会被转化成(*st.age)

2.所以st->age等价于(*st).age也等价于st.age

3.st->age等价于st.age是因为st->age是被转化成了(*st).age来执行

4.st->age的含义: st所指向的那个结构体变量中的age这个成员

```c
//结构体的存储地址
#include<stdio.h> 
struct Student  
{
	int age;
	float score;
	char sex;
};
int main(void)
{
	struct Student st = {80,60.6f,'F'};//C语言在运行float时,如果小数点后有数字,会变成double类型,需要在小数后面加f/F使其恢复成float类型,这样能减少字节的占用
	struct Student * pst = &st;//保存st的地址,需要使用&
	pst->age = 88;//第二种方式
	st.score = 61.6F;//第一种方式
	printf("%d %f\n",st.age,pst->score);//无论是使用哪种方式,都等价于另外一种方式的使用,这里输出的age和score与前面使用的方式不同,但是不影响输出
	return 0;
	//输出结果是: 88 61.599998 
    //这里的61.599998反映了浮点数无法准确存储的问题
}

```

##### 结构体变量和结构体指针变量作为函数参数传递的问题

需要使用函数修改结构体的值时,需要使用指针变量;不需要修改时,可以不使用指针变量

推荐使用结构体指针变量作为函数参数来传递

##### const

const工具的使用 作用：在函数最前加const，作用是限制该函数只能读取数据不能修改；

```c
//输入输出结构体变量
#include<stdio.h> 
#include<string.h>//这是strcpy()函数的头文件
struct Student
{
	int age;
	char sex;
	char name[100];
};//有分号!!!
void InputStudent(struct Student * );
void OutputStudent(struct Student);

int main(void)
{
	struct Student st;//定义变量名是st
	InputStudent(&st);//对结构体变量输入
	OutputStudent(st);//对结构体变量输出
	return 0;
}
void OutputStudent(struct Student ss)//不需要改变st的值,并且st的值已经通过指针修改了,可以不使用指针,ss=st,可以直接输出
{
	printf("%d %c %s\n",ss.age,ss.sex,ss.name);//%s是输出字符串,在保存字符串时如果不适用strcpy工具,会乱码
}
void InputStudent(struct Student * pstu)//需要改变st的值,所以需要使用指针,st需要加&
    									//这是一个指针,pstu只占4个字节
{
	(*pstu).age = 10;//等价于pstu.age=10;等价于pstu->age=10;
	strcpy(pstu->name,"张三");//保存输入的字符串,使用strcpy工具,第一个参数是变量名,第二个参数是保存的字符串
	pstu->sex = 'f';
}

```

```c
//对上面程序的改进
//本程序使用了指针输出结构体变量
//按照本程序的写法更快传递数据、耗用内存小、执行速度快
/*
使用指针的话发送的是地址,不使用指针的话发送的是内容
指针一直都是占用4个字节,如果是普通变量的话占用的字节加起来会太大,使用指针能更快传递数据、耗用内存小、执行速度快
但是使用指针发送（输出）的话，会导致地址泄露，需要使用在函数名前加const屏蔽小，作用是限制该函数只能传递数据而不能修改
*/
#include<stdio.h> 
#include<string.h>
struct Student//这里的字节加起来就有105个了
{
	int age;
	char sex;
	char name[100];
};
void InputStudent(struct Student * );
const void OutputStudent(struct Student * );//1.在函数最前加了const，作用是限制该函数只能读取数据不能修改；2.函数声明的形参改成了指针
int main(void)
{
	struct Student st;
	InputStudent(&st);
	OutputStudent(&st);//改成了指针
	return 0;
}
const void OutputStudent(struct Student *pst)//1.在函数最前加了const，作用是限制该函数只能读取数据不能修改；2.改成了指针
{
	printf("%d %c %s\n",pst->age,pst->sex,pst->name);//参数改成了指针取出
}
void InputStudent(struct Student * pstu)
{
	(*pstu).age = 10;
	strcpy(pstu->name,"张三");
	pstu->sex = 'f';
}
```



##### 结构体变量的运算

​	结构体变量不能相加、相减、相乘除，但可以相互赋值

```c
struct Student
{
	int age;
	char sex;
	char name[100];
};
int main(void)
{
    struct Student st1,st2;
    st1=st2;
    st2=st1;
}
```

​	举例

​			动态构造存放学生信息的结构体数组

#### 链表

### 冒泡排序(了解看懂)

```c
#include<stdio.h> 
void sort(int * a,int len)
{
	int i,j,t;
	for(i=0;i<len-1;++i)//因为有6个数,需要进行5次两两比较,并且数组是从0开始算第一个的,所以是i<len-1
	{
		for(j=0;j<len-1-i;++j)//不断从a[0]到a[5]全部进行两两比较
		//-1是因为后面有a[j+1],j<len-1的话最大值是4,在运行到4的时候a[j+1]其实就是a[5]
		//-i是因为:第一次循环结束后,前面的i会自增,这里j的最大值就会变小,循环的次数就会变少;这么做是因为每循环一次,最后的那一个数就就是最小的;循环第二次,倒数第二的那个数就是最小的;不需要进行重复的交换

		{
			if (a[j]>a[j+1])//第一个跟第二个成立的话互换,不成立不互换;执行完继续循环,从第二个跟第三个比较(如果第一次循环成立的话这里的第二个是原来的第一个)......
			{
				t = a[j];//这里的执行体是对两个数进行互换
				a[j] = a[j+1];
				a[j+1] = t;
			}
		}
	}
}
int main(void)
{
	int a[6] = {10,2,7,-8,11,0};
	int i = 0;
	sort(a,6);
	for(i = 0;i<6;++i)
	{
		printf("%d ",a[i]);
	}
	printf("\n");
	return 0;
}
```

# 学生管理系统

```c
#include<stdio.h>
#include<malloc.h>
struct Student//定义结构体
{	
	int age;
	float score;
	char name[100];
};
int main(void)
{
	int len,i,j;
	struct Student t;
	struct Student *p;
	printf("请问您要保存几位学生的成绩:");
	scanf("%d",&len);//确定保存学生信息的个数
	p=(struct Student*)malloc(len*sizeof(struct Student));//动态的构造一维数组,要注意各个数据类型的使用
    //存储学生信息
	for(i=0;i<len;i++)
	{
		printf("第%d位学生:\n",i+1);
		printf("名字:");
		scanf("%s",p[i].name);
		printf("年龄:");
		scanf("%d",&p[i].age);
		printf("分数:");
		scanf("%f",&p[i].score);
	}
    //将学生信息按分数从大到小排序(冒泡算法)
	for(i=0;i<len-1;i++)
	{
		for(j=0;j<len-1-i;j++);
		{
			if(p[i].score<p[i+1].score)
			{
				t=p[i];//这里的t要和p的数据类型相同才能赋值,所以需要定义成struct Student类型
				p[i]=p[i+1];
				p[i+1]=t;
			}
		}
	}
	printf("\n\n以下是学生的信息:\n\n");
    //输出
	for(i=0;i<len;i++)
	{
		printf("第%d名学生:\n",i+1);
		printf("名字:%s\n",p[i].name);
		printf("年龄:%d岁\n",p[i].age);
		printf("分数:%f分\n",p[i].score);
	}
	return 0;
}
```

# 枚举

### 什么是枚举

把一个事物所有可能的取值一一列举出来

### 怎样使用枚举

```c
#include<stdio.h>
enum WeekDay
{					MonDay,TuesDay,WednesDay,ThursDay,FirDay,SaturDay,SunDay
};
int main(void)
{
    enum WeekDay day=SunDay;
  	printf("%d/n",day);//输出结果是6   从0开始排
	return 0;
}
```

```c
#include<stdio.h>

enum WeekDay2
{				MonDay=3,TuesDay,WednesDay,ThursDay,FirDay,SaturDay,SunDay
};
int main(void)
{
    enum WeekDay2 day2=SunDay;
    printf("%d\n",day2);//输出结果是9  从3开始排
	return 0;
}
```

```c
#include<stdio.h>
enum WeekDay
{			
	MonDay,TuesDay,WednesDay,ThursDay,FirDay,SaturDay,SunDay
};
void f(enum WeekDay i)//本函数的目的只是期望接受0-6之间的数字,将形参i定义为变量,当发送给i是星期几时,会转化成数字
					  //如果是使用整形的话什么数据都能发eg:-1等 但如果使用枚举的话能限制发送的数据
{
	switch(i)	
	{
	case 0:
		printf("星期一!\n");
		break;
	case 1:
		printf("TuesDay!\n");
		break;
	case 2:
		printf("WednesDay!\n");
		break;
	case 3:
		printf("ThursDay!\n");
		break;
	case 4:
		printf("FirDay!\n");
		break;
	case 5:
		printf("SaturDay!\n");
		break;
	case 6:
		printf("SunDay!\n");
		break;
	}
}
int main(void)
{
    f(MonDay);//虽然MonDay本质上是5,但是直接写成f(5)是错的  输出的值是: 星期一!
	return 0;
}
```

### 枚举的优缺点

优:代码更安全(限制在一定范围内了)

缺:书写麻烦

# 进制转换

在C语言中规定八进制前要加0(这是零不是字母o),十六进制前要加0X或0x,十进制前什么都不加

在汇编中:在数字后加字母B表示二进制数,加字母O表示八进制数,加字母D表示十进制数,加字母H表示十六进制数

![image-20210202150954760](C:\Users\sp\AppData\Roaming\Typora\typora-user-images\image-20210202150954760.png)

### 十进制转r进制

==方法:不断除r取余,直到商是0,最后的余数倒序排列==

#### 例子:

#### 十进制转化成二进制

eg. 有一个十进制数是185,转化成二进制,需要不断对185进行除以2然后取余:

- 185/2=92...1
- 92/2=46. ...0
- 46/2=23.....0
- 23/2=11.....1
- 11/2=5.......1
- 5/2=2.........1
- 2/2=1.........0
- 1/2=0.........1      从这里往上倒序排列 余数=转化后的二进制数

![image-20210202151816163](C:\Users\sp\AppData\Roaming\Typora\typora-user-images\image-20210202151816163.png)

按照此办法不断将除以2所得的值继续除以2算出余数,直到值为0,然后将余数按照倒序进行排列,就是十进制转化后的二进制数了(10111001)

#### 十进制转化成十六进制

与十进制转二进制相同

![image-20210202151947298](C:\Users\sp\AppData\Roaming\Typora\typora-user-images\image-20210202151947298.png)

### r进制转十进制

```
在十进制中1234是怎么被计算出来的
1234=4*1(10的0次方)+3*10(10的1次方)+2*10*10(10的2次方)+1*10*!0*10(10的3次方)=1234

在十六进制中的1234转化成十进制
1234=4*1(16的0次方)+3*16(16的1次方)+2*16*16(16的2次方)+1*16*16*16(16的3次方)=4660

在八进制中的1234转化成十进制
1234=4*1(8的0次方)+3*8(8的1次方)+2*8*8(8的2次方)+1*8*8*8(8的3次方)=668

在二进制中的10101转化成十进制
10101=1*1(2的0次方)+0*2(2的1次方)+1*2*2(2的2次方)+0*2*2*2(2的3次方)+1*2*2*2*2(2的4次方)=21
```

### 二进制与十六进制的转化

#### 二进制转十六进制

方法:从右到左,四位一段,分别转化,不够四位的要在前面补0

eg . 0101110  它的后四位构成十六进制的个位数,往前的4位是10位数,但是只有三位,所以要在三位的前面补0,凑成四位作为十六进制的十位,最终补成00101110;

原理:1111是15,十六进制是逢16进1,1111是它的最大值,所以用4位数最为十六进制的一个位,并且及时十六进制数是1,也要用四位的二进制0001表示

eg. 11010 -->00011010

#### 十六进制转二进制

与二进制转十六进制类似

方法:将每一个十六进制位转化为四个二进制位

eg.   2E --> 00101110   (后四位表示14,前四位表示2)

### 二进制与八进制的转化

#### 二进制转八进制

实际跟二进制与十六进制的转化类似.只不过从4位二进制变成了3位

方法:从右向左,三位一段,分别转化,不够三位的补0

eg.  0101110可以看成 000 101 110 (最前面补了两个0) 再按分成的几段转化成8进制是:056

​		11010  -->  011 010  -->  32

#### 八进制转二进制

与二进制转八进制类似

方法:将每一个八进制位转化为三个二进制位

eg:  27 --> 010 111

​		34 --> 011 100

### 十六进制与八进制的转化

不存在十六进制与八进制的直接相互转化,只能以二进制作为中间进制来进行转化

# 补码

### 原码

​	也叫  符号-绝对值码

​	最高位(最前位)0表示正 1表示负,其余二进制位是该数字的绝对值的二进制位

​	原码简单易懂

​	加减运算复杂

​	存在加减乘除四种运算,增加了CPU得到复杂度

​	零的表示不唯一

### 反码

​	反码运算不方便,也没在计算机中应用

### 移码

​	移码表示数值平移n位,n称为移码量

​	移码主要用于浮点数的阶码的存储

### 补码

#### 已知十进制求二进制

##### 求正整数的二进制

除2取余,直至商为零,余数倒序排列 就是二进制的表示

##### 求负整数的二进制

先求与该负数相对应的正整数的二进制代码,然后将所有位取反,==末尾加1==,不够位数时,在左边补1

eg.  -5  的正整数二进制代码是0101(因为是正的,最前面应该是0)取反后是1010   末尾加1是1011

==不够位数在左边补1==:看占的字节,因为-3是int类型.一般占4个字节,1个字节有8位,一共占了32位,1011是4位,需要在前面补28个1,但是数字太多,我们可以用十六进制表示,比如这里可以表示成FFFFFFF5,因为4个1就是一个F,因此FFFFFFF5就是-5;

##### 求零的二进制

全是零

#### 已知二进制求十进制

如果首位是0,则表明是正整数,按普通方法求

如果首位是1,则表明是负整数,要将所有位取反,==末尾加1==,所得的数字就是该负数的绝对值

如果全是零,则对应的十进制数字就是零

### 补码的字节

上面提到的不够位数在左边补1，因为需要补足字节系统才能识别出

一般int类型是4个字节，系统存储会补满字节，但如果字节满了，就不会补

```c
//char下的128输出是-128
#include<stdio.h>
int main(void)
{
	char ch = 0x80;//表示值是十六进制的80
	ch=128;
	printf("%d\n",ch);//输出结果是-128
}
//实际上上面的1000 0000经过了补码，128的代码是1000 0000，由于输入的是正数，系统在存储时会对前面自动补0占满字节表示这是正数，但是由于char只有一个字节，并且一个字节是8位，128的二进制代码已经占了八位，无法进行补0；这就导致在输出时二进制代码开头是1，系统认为是负数，对其进行全部位取反加1后的二进制代码是1000 0000，得出是-128
//如果此时类型是2个字节的话，系统补码后的二进制代码是0000 0000 1000 0000（没有空格的）；系统会自动在前面补0表示是正数，最后会正常输出128 
```

```c
//char下的129输出是-127
#include<stdio.h>
int main(void)
{
	char ch = 0x80;
	ch=129;
	printf("%d\n",ch);//输出的是-127
}
//这样的原因是因为经过补码，129的二进制代码是1000 0001 
//在存储时由于输入的是正数，系统自动对前面进行补0，但是没有位可以补，导致最高为是1，系统判定为是负数，随后进行取反加1，最终的代码是01111 1111，值是127，但是由于存储时系统判定为负数了，所以最终输出的是-127
```

![image-20210202203022862](C:\Users\sp\AppData\Roaming\Typora\typora-user-images\image-20210202203022862.png)

在vc6.0++中一个int类型的变量所能存储的数字范围是多少

int类型变量所能存储的最大正数用十六进制表示是：7FFFFFFF  二进制:1个0加上31个1

int类型变量所能存储的绝对值最大的负整数用十六进制表示是:80000000 二进制:1个1加上31个0

# 链表

我们至少可以通过两种结构来存储数据:数组和链表

数组

​		优点:存取速度快

​		缺点:需要一个连续的很大的内存

​				 插入和删除元素的效率很低

链表

​		优点:插入删除元素效率很高

​				 不需要一个连续的很大的内存

​		缺点:插入和删除元素的效率很低

### 链表

专业术语:

​			首节点:存放第一个有效数据的节点

​			尾节点:存放最后一个有效数据的节点(尾节点的指针域是空)

​			头节点:(头节点的数据域是空)

1. 头节点的数据类型和首节点的类型是相同的
2. 头节点是首节点前面的那个节点
3. 头节点并不存放有效数据
4. 设置头节点的目的是为了方便对链表的操作



​			头指针:存放头节点地址的指针变量

通过一个头指针指向头节点。最前面的是头节点,之后是首节点,真正有效的数据是在首节点存放的,头节点不存放数据。

确定一个链表需要一个参数：头指针

```c
#include<stdio.h>
#include<malloc.h>

//定义一个链表节点的数据类型
struct Node//这是一个数据类型
{
	int data;//数据域
	struct Node * pNext;//指针域(用来指向下一个数据)
};
//函数声明
struct Node * CreateList(void);
void TraverseList(struct Node *);


int main(void)
{
	struct Node * pHead = NULL;  //pHead是头指针,用来存放链表头节点的地址 
	
	pHead = CreateList();//造出一个函数,存放链表的头节点地址,发给pHead
	TraverseList(pHead);

	return 0;
}

struct Node * CreateList(void)
{
	int len;//用户输入,确定节点的个数
	int i;
	int val;//临时存放用户输出的节点的值

	//分配出一个不存放有效数据的头节点
	struct Node * pHead = (struct Node *)malloc(sizeof(struct Node));
	if(NULL == pHead)
	{
		printf("分配失败,程序终止!\n");	
	
	}
	struct Node * pTail = pHead;
	pTail->pNext = NULL;

	printf("请输出您需要生成的链表节点的个数:len=");
	scanf("%d",&len);


	for(i = 0;i<len;++i)
	{
		printf("请输入第%d个节点的值",i+1);
		scanf("%d",&val);
	//每循环一次造一个节点
		struct Node * pNew = (struct Node *)malloc(sizeof(struct Node));
		if(NULL == pNew)
		{
			printf("分配失败,程序终止!\n");
	
		}
	//把节点插到头指针后面
		pNew->data = val;
		pNew->pNext = NULL;
		pTail->pNext = pNew;
		pTail = pNew;//(无法理解)
	}
	return pHead;
}
/*用来判断头节点的存放地址是否为空 但我们已经设置它为空了,所以不需要用到
bool empty_list(struct Node * pHead)
{
	if(pHead->pNext == NULL)
		return true;
	else
		return false;
}
*/
void TraverseList(struct Node * pHead)
{
	/*上面的bool判断
	if(empty_list(pHead))
	{
		printf("链表为空");
	}
	*/

	struct Node * p = pHead->pNext;//建立一个p指针指向Head的指针域
	while(NULL!=p)
	{
		printf("%d\n",p->data);//输出第一个数据的值
		p = p->pNext;//移到后一个数据
	}

	return;
}

```

### 算法

通俗定义：解题的方法和步骤

狭义定义：对存储数据的操作

​					比如对不同的存储结构，要完成某一个功能所执行的操作是不一样的

​					eg.输出数组中所有元素的操作和输出链表中所有元素的操作

​					这说明：==算法是依附于存储结构的==

​									==不同的存储结构，所执行的算法是不一样的==

广义定义：广义的算法也叫泛型

​					无论数据是如何存储的，对数据的操作都是一样的

```c
//广义的
#included<stdio.h>
int main(void)
{
    int a[10]={1,2,3,4};
    int * ph = a;
    for(i=0;i<10;++i)//通过这个循环可以对数组内的 数据进行输出
    {
		printf("%d\n",*ph);
        ph++;//在链表中这个语句改成ph=ph->pNext;可以执行对链表的输出
    }  
}
```

# 位运算符

### & 

&--按位于

&&--逻辑与 也叫并且

&与&&的含义不同

eg. 5&7 = 5  21&7 = 5  5&1 = 1  5&10 = 0

在这里的&表示将5和7的二进制位进行比较,1算真,0算假

规则:

1&1=1;

1&0=0;

0&1=0;

0&0=0;

5的二进制是0101  7的二进制是0111,按照上面的规则的出最终的二进制是0101,所以值是0

### |

| --按位或

||  --逻辑或

与&类似,但规则不同

规则: 

1|0 = 1;

1|1 = 1;

0|1 = 1;

0|0 = 0;

### ~

~  --按位取反

~i就是把i变量所有的二进制位取反(注意正负也会改变)

### ^

^ --按位异或

二进制对应位相同为0 不同为1

1^0=1;

1^1=0;

0^1=1;

0^0=0;

### <<

按位左移

==i<<3表示把i的所有二进制左移3位,右边剩下的3位补0==

==左移n位相当于乘以2的n次方,但前提是数据不能丢失==

==面试题:==

   1. ==i = i*8;==

   2. ==i = i<<3;==

      ==请问上述语句,哪个执行的速度快.答案2.==

### >>

按位右移

i>>3表示把i的所有二进制位右移3位,左边的三位补0/1(最高位是1时补1,是0补0)

右移n位相当于除以2的n次方,但前提是数据不能丢失

   1. ==i = i/8;==

   2. ==i = i>>3;==

      ==请问上述语句,哪个执行的速度快.答案2.==

### 位运算符的现实意义

通过位运算符我们可以对数据的操作精确到每一位

# 二进制全部为0的含义

0000000000000000000的含义

1.数值零

2.字符串结束标记符'\0'  (字符串的存储是不含0的)

3.==空指针NULL==（NULL用于指针p=NULL；）

​		NULL本质上是零,但是这个零不是数字零,而是内存单元的编号是零

​	我们计算机规定了,以零为编号的存储单元的内容不可读、不可写

# 郝斌C语言测试题

### 什么叫分配内存，什么叫释放内存

分配内存是请求操作系统将某块内存空间的使用权限分给程序

释放内存是操作系统把分配给该程序的内存空间的使用权限收回，该程序就不能够再使用这一块内存空间

注：释放内存不是把内存的内容清零；

### 变量为什么得初始化

不初始化，变量通常是垃圾值

### 详细说明系统是如何执行：int=5；

1.软件请求操作系统为i分配存储空间

2.操作系统会在系统内存中寻找一块空闲的区域，把该区域当作i使用

3.软件会把i和这块空闲区域关联起来，之后对字母i的操作就是对这块空闲的区域操作

4.把5存储到字母i关联的内存区域中

Z：所谓内存区域就是内存的一块存储单元

### C语言的所有基本类型

int ; long int ; shor int ;  char;  float;  double;

### long  int;char;double;float;分别用什么输出

%ld    %c    %lf   %f

### 函数的优点

1.避免重复性操作(减少代码量)

2.有利于程序的模块化

### 谈谈你对函数的理解



### 什么是指针,什么是地址,什么是指针变量,三者之间的关系

地址是内存单元的编号 指针就是地址  地址和指针是同一个概念

指针变量是存放内存单元编号的变量  指针变量和指针是两个完全不同的概念

但是平时人们大多数把指针变量简称为指针

### 静态变量和动态变量的相同与不同

相同:都需要分配内存

不同:

​	静态变量是由系统自动分配,自动释放,程序员无法在程序运行的过程中手动分配,也无法在程序运行的过程中手动释放;

静态变量是在栈中分配的;

只有在函数终止之后,静态变量的存储空间才会被系统自动释放;



​	动态变量是由程序员手动分配,手动释放,程序员可以在程序运行的过程中手动分配,也可以在程序运行的过程中手动释放;

动态变量是在堆中分配的;

程序员可以在函数执行的过程中的任何一个时刻手动的释放动态变量的空间, 不需要等到函数终止时才释放

### C语言中学习的重点

流程控制 函数 指针 静态内存和动态内存